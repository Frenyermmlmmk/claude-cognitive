# Foraging Agent - Autonomous Codebase Discovery

> **File**: `scripts/forage.py` (v1.2 Phase 4)
> **Purpose**: Auto-discover codebase patterns, generate `.claude/*.md` files
> **Philosophy**: Ralph Loop - iterative discovery with feedback and learning
> **Status**: Design phase (Phase 4, weeks 7-8)

---

## The Vision

**Current onboarding (v1.1):**
```
1. User discovers claude-cognitive
2. User manually creates .claude/{modules,systems,integrations}/
3. User writes .md files describing their architecture
4. User customizes keywords to match their project
5. Takes hours/days → many users give up
```

**With Foraging Agent (v1.2):**
```
1. User runs: claude
2. Foraging agent activates on first session
3. Agent analyzes codebase, discovers patterns
4. Agent generates .claude/modules/discovered-*.md files
5. Router picks them up automatically
6. Takes <5 minutes → zero-config experience
```

---

## Ralph Loop Pattern

**Core Philosophy**: Iteration beats perfection

```
while not converged():
    # Iteration
    discover_patterns()

    # Action
    generate_md_files()

    # Feedback delay
    wait_for_usage_data(min_turns=20)

    # Objective feedback
    usefulness = measure_usefulness()

    # Learning
    if usefulness < threshold:
        adjust_discovery_strategy()
        cleanup_failed_discoveries()
    else:
        promote_to_permanent()

    # Safeguards
    check_circuit_breakers()
```

**Key Insight**: Don't expect perfect discovery on first attempt. Try, measure, learn, retry with better strategy.

---

## What to Discover

### 1. Core Modules (High-Impact Files)

**Strategy**: Find frequently-imported files

```python
# Scan all Python files
imports = analyze_imports(codebase)

# Find most-imported modules
core_modules = [
    module for module, count in imports.items()
    if count > 20  # Imported in 20+ files
]

# Generate .claude/modules/discovered-<name>.md
for module in core_modules:
    generate_module_doc(module, import_count=count)
```

**Example Output**: `.claude/modules/discovered-session-manager.md`

```markdown
# Session Manager (Auto-Discovered)

**Location**: `core/database.py:SessionManager`
**Usage**: Imported in 47 files across project
**Discovery Confidence**: High (>20 imports)

## Purpose
Central database session management (inferred from import patterns)

## Key Methods
- `get_session()` - Most frequently called (127 references)
- `commit_transaction()` - Often paired with error handlers (43 references)
- `rollback()` - Error recovery pattern (38 references)

## Common Usage Patterns
- Usually accessed in try/except blocks with rollback on failure
- Frequently co-occurs with: UserModel (31 files), TransactionLog (24 files)

## Auto-Generated Keywords
session, database, transaction, commit, rollback, connection

---
Auto-generated by claude-cognitive foraging agent v1.2
Last updated: 2026-01-03 18:45:21
Usefulness score: Pending (need 20 turns of usage data)
Discovery iteration: 1
```

### 2. Entry Points (Main Files)

**Strategy**: Find files with `if __name__ == "__main__"`

```python
entry_points = find_entry_points(codebase)

for entry in entry_points:
    generate_entry_point_doc(entry)
```

**Example**: `.claude/modules/discovered-main-entry.md`

### 3. Configuration Files

**Strategy**: Find `config.py`, `settings.py`, `.env` readers

```python
config_files = find_config_files(codebase)
```

### 4. Common Patterns

**Strategy**: Detect architectural patterns

```python
patterns = detect_patterns(codebase)
# - Factory pattern
# - Singleton pattern
# - Observer pattern
# - Dependency injection
# etc.
```

### 5. API Endpoints (if web app)

**Strategy**: Find Flask/FastAPI/Django routes

```python
if is_web_app(codebase):
    endpoints = discover_api_endpoints(codebase)
```

---

## Discovery Strategies

### Strategy 1: Import Frequency (Phase 1 - Simple)

**Confidence**: High
**Speed**: Fast
**Coverage**: Core modules only

```python
def discover_by_imports(codebase):
    """Find most-imported files"""
    imports = {}

    for py_file in codebase.glob("**/*.py"):
        # Parse imports
        tree = ast.parse(py_file.read_text())
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports[alias.name] = imports.get(alias.name, 0) + 1

    # Return top 10 most-imported
    return sorted(imports.items(), key=lambda x: x[1], reverse=True)[:10]
```

### Strategy 2: Function Call Frequency (Phase 2 - Deeper)

**Confidence**: High
**Speed**: Medium
**Coverage**: Core functions within modules

```python
def discover_by_function_calls(codebase):
    """Find most-called functions"""
    # Requires static analysis
    # Track: function_name → call_count
    pass
```

### Strategy 3: Git History (Phase 3 - Temporal)

**Confidence**: Medium
**Speed**: Medium
**Coverage**: Actively-developed files

```python
def discover_by_git_activity(codebase):
    """Find recently/frequently modified files"""
    # Git log analysis
    # Files changed in last 30 days
    # Files with most commits
    pass
```

### Strategy 4: Semantic Clustering (Phase 4 - Advanced)

**Confidence**: Medium-Low
**Speed**: Slow
**Coverage**: Conceptual groupings

```python
def discover_by_semantic_clustering(codebase):
    """Group related files by embeddings"""
    # Generate embeddings for all files
    # Cluster similar files
    # Generate module docs per cluster
    pass
```

---

## Iterative Refinement (Ralph Loop)

### Iteration 1: Broad Discovery

```
Goal: Cast wide net, discover 10-15 files
Strategy: Import frequency (>10 imports)
Threshold: Low confidence OK

Result:
  Discovered: 12 files
  Generated: 12 .md files
  Wait for: 20 turns of usage data
```

### Iteration 2: Measure Usefulness

```
Analyze: Which discoveries were actually useful?

Results after 20 turns:
  - session-manager.md: 0.85 usefulness ✅ KEEP
  - auth-handler.md: 0.78 usefulness ✅ KEEP
  - config-loader.md: 0.73 usefulness ✅ KEEP
  - cache-handler.md: 0.35 usefulness ⚠️ MARGINAL
  - logger.md: 0.28 usefulness ⚠️ MARGINAL
  - utils.md: 0.12 usefulness ❌ REMOVE (too generic)
  - (6 more files with varying scores)

Average: 0.58 usefulness (58% success rate)

Action: Keep 8 files, remove 4 low-utility files
```

### Iteration 3: Adjust Strategy

```
Analysis:
  - High-import files (>30 imports) → 85% useful
  - Medium-import files (10-30 imports) → 45% useful
  - Generic names (utils, helpers) → 15% useful

Strategy Adjustment:
  - Raise import threshold: 10 → 20 imports
  - Exclude generic names: utils.py, helpers.py, common.py
  - Focus on domain-specific modules

Re-run: Discover 8 new files with adjusted strategy
```

### Iteration 4: Validate Improvement

```
Results after 20 turns:
  Average usefulness: 0.72 (up from 0.58) ✅ IMPROVING

Convergence check:
  - Iteration 1: 58% useful
  - Iteration 2: 72% useful
  - Delta: +14% (significant improvement)
  - Continue: Not converged yet (need 3 consecutive >70%)
```

### Iteration 5: Convergence

```
Results after 20 turns:
  Average usefulness: 0.74 (up from 0.72)

Convergence check:
  - Iteration 2: 72%
  - Iteration 3: 74%
  - Iteration 4: 75%
  - Delta: <5% change over 3 iterations
  - Converged: YES ✅

Action: Stop foraging, promote discoveries to permanent
```

---

## File Generation

### Template Structure

```markdown
# {Module Name} (Auto-Discovered)

**Location**: `{file_path}:{class_name}`
**Usage**: {context about usage}
**Discovery Confidence**: {High|Medium|Low}

## Purpose
{Inferred purpose from code analysis}

## Key {Functions|Classes|Methods}
- `{name}()` - {description} ({reference_count} references)

## Common Usage Patterns
{Patterns detected in how this module is used}

## Dependencies
- Imports: {list of imports}
- Imported by: {list of files that import this}

## Auto-Generated Keywords
{keywords}, {extracted}, {from}, {content}

---
Auto-generated by claude-cognitive foraging agent v1.2
Last updated: {timestamp}
Usefulness score: {score or "Pending"}
Discovery iteration: {iteration_number}
Discovery strategy: {strategy_name}
```

### Metadata Footer (Critical)

```markdown
---
AUTO_GENERATED: true
AGENT_VERSION: v1.2.0
DISCOVERY_STRATEGY: import_frequency
ITERATION: 3
CONFIDENCE: high
USEFULNESS: 0.85
LAST_VALIDATED: 2026-01-03T18:45:21Z
SAFE_TO_DELETE: true  # Agent can delete this
---
```

**Why metadata matters:**
- Distinguishes auto-generated from user-written files
- Enables safe cleanup (never delete user files)
- Tracks learning progress
- Documents discovery provenance

---

## Cleanup Strategy

### When to Remove Discoveries

```python
def should_cleanup(discovery):
    """Decide if auto-generated file should be removed"""

    # Criterion 1: Low usefulness
    if discovery.usefulness < 0.3:
        return True, "Low utility (<30%)"

    # Criterion 2: Stale (not validated recently)
    if days_since(discovery.last_validated) > 30:
        return True, "Stale (not validated in 30 days)"

    # Criterion 3: Superseded by user-written file
    if user_wrote_equivalent(discovery):
        return True, "User provided better version"

    # Criterion 4: Duplicate
    if is_duplicate(discovery):
        return True, "Duplicate of existing file"

    return False, "Keep (useful)"
```

### Archive, Don't Delete

```python
# Instead of deleting, archive
shutil.move(
    ".claude/modules/discovered-utils.md",
    ".claude/archive/discovered-utils-2026-01-03.md"
)

# Log for transparency
log_cleanup(file, reason, usefulness_score)
```

---

## Circuit Breakers (Safeguards)

### 1. Generation Runaway

```python
if files_generated > 50:
    raise CircuitBreakerTripped("Generated too many files (>50)")
```

### 2. Disk Space

```python
if disk_usage() > 0.95:  # >95% full
    raise CircuitBreakerTripped("Disk space critical")
```

### 3. Duplicate Detection

```python
if duplicate_count > 5:
    raise CircuitBreakerTripped("Generating duplicates")
```

### 4. Low Usefulness Threshold

```python
if avg_usefulness < 0.2 for 3 consecutive iterations:
    raise CircuitBreakerTripped("Discoveries consistently not useful")
```

### 5. Iteration Limit

```python
if iteration > 10:
    raise CircuitBreakerTripped("Max iterations reached")
```

---

## Scheduling

### When to Forage

**Option 1: First Session**
```python
if not os.path.exists(".claude/attn_state.json"):
    # First-time user, run foraging
    run_foraging_agent()
```

**Option 2: Idle Time**
```python
if minutes_since_last_activity() > 5:
    # Idle for 5+ minutes, safe to forage
    run_foraging_agent()
```

**Option 3: Manual Trigger**
```bash
python ~/.claude/scripts/forage.py --project /path/to/project
```

**Option 4: Scheduled (Cron)**
```bash
# Run nightly at 2am
0 2 * * * python ~/.claude/scripts/forage.py
```

---

## Integration with Context Router

### Discovered Files Get Attention

```python
# context-router-v2.py

def load_claude_files():
    """Load both user-written and auto-discovered files"""

    files = []

    # User-written (priority)
    files.extend(glob(".claude/modules/*.md"))
    files.extend(glob(".claude/systems/*.md"))
    files.extend(glob(".claude/integrations/*.md"))

    # Filter auto-discovered that aren't superseded
    for md_file in files:
        if is_auto_generated(md_file):
            if not superseded_by_user(md_file):
                # Still valid, include in routing
                pass
            else:
                # User wrote better version, archive auto-gen
                archive_discovery(md_file)

    return files
```

### Keywords from Discoveries

```python
# Auto-discovered files include keywords
# Router treats them same as user keywords

for md_file in discovered_files:
    keywords = extract_keywords(md_file)
    KEYWORDS.update(keywords)
```

---

## Testing Strategy

### Phase 1: Dry Run (Observe, Don't Generate)

```python
# Test discovery logic without creating files
forage = ForagingAgent(mode="dry_run")
discoveries = forage.discover(codebase)

# Log what would be generated
for discovery in discoveries:
    print(f"Would generate: {discovery.filename}")
    print(f"  Confidence: {discovery.confidence}")
    print(f"  Strategy: {discovery.strategy}")
```

### Phase 2: Generate Without Router

```python
# Generate files, but don't integrate with router yet
forage = ForagingAgent(mode="generate")
forage.discover_and_generate(codebase)

# Manually review generated .md files
# Check quality, accuracy, usefulness
```

### Phase 3: Integrated Testing

```python
# Full integration: generate + route + measure
forage = ForagingAgent(mode="full")
forage.run_iteration()

# Wait 20 turns
# Measure usefulness via usage tracking
# Validate learning loop
```

### Phase 4: Convergence Testing

```python
# Run full Ralph Loop to convergence
forage = ForagingAgent(mode="full")
forage.run_until_convergence(max_iterations=10)

# Verify:
# - Converges in <10 iterations
# - Final usefulness >70%
# - No circuit breakers tripped
```

---

## Success Criteria

**Phase 4 Complete When:**
- ✅ Zero-config discovery works on fresh projects
- ✅ Discovers 8-12 core modules accurately
- ✅ Generated .md files are coherent and useful
- ✅ Usefulness >70% by iteration 3-5
- ✅ Convergence detection prevents infinite iteration
- ✅ Circuit breakers protect against runaway generation
- ✅ Cleanup removes low-value discoveries safely

**Quantitative Targets:**
- Discovery accuracy: >80% of discoveries are useful
- Convergence time: <5 iterations
- Time to first useful context: <5 minutes (vs hours manually)
- Coverage: Top 10 most-important files discovered

---

## Known Limitations

### 1. Code Quality Dependency

```
High-quality code → Good discoveries
Messy code → Poor discoveries
```

**Mitigation**: Start with import frequency (objective metric)

### 2. Domain Knowledge Gap

```
Agent doesn't understand business logic
Can describe structure, not purpose
```

**Mitigation**: User can edit auto-generated files to add context

### 3. False Positives

```
May generate .md for unimportant files
E.g., test files, utilities
```

**Mitigation**: Usage tracking + cleanup removes false positives

### 4. Language-Specific

```
Phase 1: Python only
Phase 2: JavaScript/TypeScript
Phase 3: Other languages
```

---

## Future Enhancements

### v1.3: Multi-Language Support

- JavaScript/TypeScript AST parsing
- Java/C++/Rust analysis
- Language-agnostic patterns

### v1.4: Semantic Understanding

- Use LLM to generate better descriptions
- Infer purpose from code comments
- Generate usage examples

### v1.5: Interactive Refinement

- Ask user to validate discoveries
- "Is `session-manager.md` correctly describing this module?"
- Learn from user corrections

---

## Example: Real-World Foraging

**Project**: claude-cognitive itself (dogfooding)

### Iteration 1: Initial Discovery

```bash
$ python scripts/forage.py

Foraging agent v1.2 starting...
Project: claude-cognitive-package/
Strategy: import_frequency (threshold: 10 imports)

Analyzing Python files... 42 files found
Parsing imports...

Discovered core modules:
  1. scripts/context-router-v2.py (18 imports)
  2. scripts/pool-loader.py (12 imports)
  3. scripts/history.py (11 imports)
  4. scripts/pool-auto-update.py (10 imports)

Generating .claude/modules/discovered-*.md files...
  ✓ discovered-context-router.md (confidence: high)
  ✓ discovered-pool-loader.md (confidence: high)
  ✓ discovered-history.md (confidence: medium)
  ✓ discovered-pool-auto-update.md (confidence: medium)

Waiting for usage data (20 turns)...
Check progress: cat .claude/learning_progress.txt
```

### After 20 Turns: Usefulness Analysis

```
Results:
  - context-router.md: 0.92 usefulness ✅ Excellent
  - pool-loader.md: 0.68 usefulness ✅ Good
  - history.md: 0.45 usefulness ⚠️ Marginal
  - pool-auto-update.md: 0.23 usefulness ❌ Low

Actions:
  Keep: context-router, pool-loader (useful)
  Archive: history, pool-auto-update (low utility in current workflow)

Convergence: Not yet (need iteration 2 with adjusted strategy)
```

---

**Status**: Design complete, ready for Phase 4 implementation
**Prerequisites**: Phase 1 (Usage Tracking) must be complete first
**See**: `V1.2_INTELLIGENCE_ROADMAP.md` for implementation timeline
